package com.ctrip.soa.caravan.ribbon.serversource.monitor;import com.ctrip.soa.caravan.ribbon.*;import com.ctrip.soa.caravan.ribbon.loadbalancer.DefaultLoadBalancer;import com.ctrip.soa.caravan.ribbon.loadbalancer.LoadBalancerContext;import com.ctrip.soa.caravan.ribbon.serversource.DefaultDynamicServerSource;import com.ctrip.soa.caravan.ribbon.serversource.DefaultServerSource;import com.ctrip.soa.caravan.ribbon.serversource.filter.ServerSourceFilter;import com.google.common.base.Predicate;import org.junit.Assert;import org.junit.Test;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by w.jian on 2016/6/22. */public class DefaultServerSourceMonitorTest {    final String indexKey = "Index";    final String managerId = "soa";    @Test    public void pingFailureServerToSuccess_SingleServer_Test() throws Exception {        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        pingFailureServerToSuccessTest(lbId, 1);    }    @Test    public void pingFailureServerToSuccess_MultiServer_Test() throws Exception {        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        pingFailureServerToSuccessTest(lbId, 10);    }    private void pingFailureServerToSuccessTest(String lbId, final int serverCount) throws Exception {        final LoadBalancerRequestConfig requestConfig = new LoadBalancerRequestConfig(lbId);        List<Server> servers = getServers(serverCount);        DefaultServerSource serverSource = DefaultDynamicServerSource.fromServers(lbId, servers);        DefaultPing ping = new DefaultPing(false);        LoadBalancerConfig config = new LoadBalancerConfig.Builder().setPing(ping).setServerSource(serverSource).build();        LoadBalancerManager factory = LoadBalancerManager.getManager(managerId, TestUtils.getLoadBalancerManagerConfig());        final LoadBalancer loadBalancer = factory.getLoadBalancer(lbId, config);        DefaultLoadBalancer defaultLoadBalancer = (DefaultLoadBalancer)loadBalancer;        ServerSourceFilter serverSourceFilter = defaultLoadBalancer.getLoadBalancerContext().serverSourceFilter();        List<Server> allServers = serverSourceFilter.getLoadBalancerRoute(requestConfig).getServers();        for (Server server : allServers) {            server.setAlive(false);        }        serverSourceFilter.refresh();        List<Server> availableServers = serverSourceFilter.getLoadBalancerRoute(requestConfig).getAvailableServers();        Assert.assertEquals(0, availableServers.size());        ping.setSuccess(true);        Thread.sleep(3000);        for (Server server : allServers) {            Assert.assertTrue(server.toString(), server.isAlive());        }    }    @Test    public void monitorWithCallStatusTest() throws InterruptedException {        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        monitorWithCallStatusAndPing(lbId, null);    }    @Test    public void monitorWithCallStatusAndPingTest() throws InterruptedException {        DefaultPing ping = new DefaultPing(false);        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        monitorWithCallStatusAndPing(lbId, ping);    }        private void monitorWithCallStatusAndPing(String lbId, DefaultPing ping) throws InterruptedException {        final int serverCount = 10;        final int repeatTimes = 3;        final int sleepInterval = 100;        final Predicate<Integer> predicate = new Predicate<Integer>() {            @Override            public boolean apply(Integer input) {                return input % 2 ==0;            }        };        final LoadBalancerRequestConfig requestConfig = new LoadBalancerRequestConfig(lbId);        List<Server> servers = getServers(serverCount);        LoadBalancerManager factory = LoadBalancerManager.getManager(managerId, TestUtils.getLoadBalancerManagerConfig());        DefaultDynamicServerSource serverSource = DefaultDynamicServerSource.fromServers(lbId, servers);        LoadBalancerConfig config = new LoadBalancerConfig.Builder().setPing(ping).setServerSource(serverSource).build();        final LoadBalancer loadBalancer = factory.getLoadBalancer(lbId, config);        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                while(true) {                    LoadBalancerRequestContext requestContext = loadBalancer.getRequestContext(requestConfig);                    Map<String, String> metadata = requestContext.getServer().getMetadata();                    int index = Integer.parseInt(metadata.get(indexKey));                    if (predicate.apply(index))                        requestContext.markServerAvailable();                    else                        requestContext.markServerUnavailable();                    sleep(sleepInterval);                }            }            private void sleep(long millis) {                try {                    Thread.sleep(millis);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        thread.setDaemon(true);        thread.start();        Thread.sleep(serverCount * repeatTimes * sleepInterval);        DefaultLoadBalancer defaultLoadBalancer = (DefaultLoadBalancer)loadBalancer;        ServerSourceFilter serverSourceFilter = defaultLoadBalancer.getLoadBalancerContext().serverSourceFilter();        List<Server> allServers = serverSourceFilter.getLoadBalancerRoute(requestConfig).getServers();        for(Server server : allServers) {            int index = Integer.parseInt(server.getMetadata().get(indexKey));            if(predicate.apply(index))                Assert.assertTrue(server.toString(), server.isAlive());            else                Assert.assertFalse(server.toString(), server.isAlive());        }    }        @Test    public void RetainMinAvailableServerCount_MultiServer_Test() throws InterruptedException {        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        RetainMinAvailableServer(lbId, 10);    }        @Test    public void RetainMinAvailableServerCount_MinAvailableServerCount_Test() throws InterruptedException {        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        RetainMinAvailableServer(lbId, 4);    }        private void RetainMinAvailableServer(String lbId, final int serverCount) throws InterruptedException {        final int repeatTimes = 3;        final int sleepInterval = 100;        final LoadBalancerRequestConfig requestConfig = new LoadBalancerRequestConfig(lbId);            List<Server> servers = getServers(serverCount);            LoadBalancerManager factory = LoadBalancerManager.getManager(managerId, TestUtils.getLoadBalancerManagerConfig());        DefaultDynamicServerSource serverSource = DefaultDynamicServerSource.fromServers(lbId, servers);        LoadBalancerConfig config = new LoadBalancerConfig.Builder()                .setPing(new DefaultPing(false))                .setServerSource(serverSource)                .build();        final LoadBalancer loadBalancer = factory.getLoadBalancer(lbId, config);        DefaultLoadBalancer defaultLoadBalancer = (DefaultLoadBalancer)loadBalancer;        ServerSourceFilter serverSourceFilter = defaultLoadBalancer.getLoadBalancerContext().serverSourceFilter();        LoadBalancerContext loadBalancerContext = defaultLoadBalancer.getLoadBalancerContext();                Thread thread = new Thread(new Runnable() {            @Override            public void run() {                while(true) {                    LoadBalancerRequestContext requestContext = loadBalancer.getRequestContext(requestConfig);                    requestContext.markServerUnavailable();                    sleep(sleepInterval);                }            }                    private void sleep(long millis) {                try {                    Thread.sleep(millis);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        thread.setDaemon(true);        thread.start();            Thread.sleep(serverCount * repeatTimes * sleepInterval);                int minAvailableServerCount = loadBalancerContext.getMinAvailableServerCount();        System.out.println("MinAvailableServerCount:" + minAvailableServerCount);        Assert.assertEquals(serverCount, serverSourceFilter.getLoadBalancerRoute(requestConfig).getServers().size());        Assert.assertEquals(minAvailableServerCount, serverSourceFilter.getLoadBalancerRoute(requestConfig).getAvailableServers().size());    }        @Test    public void checkHealthExecutorServiceTest() {        String lbId = Thread.currentThread().getStackTrace()[1].getMethodName();        List<Server> servers = getServers(10);        LoadBalancerManager factory = LoadBalancerManager.getManager(managerId, TestUtils.getLoadBalancerManagerConfig());        DefaultDynamicServerSource serverSource = DefaultDynamicServerSource.fromServers(lbId, servers);        LoadBalancerConfig config = new LoadBalancerConfig.Builder()                .setPing(new DefaultPing(false))                .setServerSource(serverSource)                .build();                final LoadBalancer loadBalancer1 = factory.getLoadBalancer(lbId + "-1", config);        DefaultLoadBalancer defaultLoadBalancer1 = (DefaultLoadBalancer)loadBalancer1;        LoadBalancerContext loadBalancerContext1 = defaultLoadBalancer1.getLoadBalancerContext();                final LoadBalancer loadBalancer2 = factory.getLoadBalancer(lbId + "-2", config);        DefaultLoadBalancer defaultLoadBalancer2 = (DefaultLoadBalancer)loadBalancer2;        LoadBalancerContext loadBalancerContext2 = defaultLoadBalancer2.getLoadBalancerContext();                Assert.assertTrue(loadBalancerContext1.getCheckHealthExecutorService() == loadBalancerContext2.getCheckHealthExecutorService());    }        private List<Server> getServers(int serverCount) {        List<Server> servers = new ArrayList<>();        for (int i = 0; i < serverCount; i++) {            HashMap<String, String> metadata = new HashMap<>();            metadata.put(indexKey, Integer.toString(i));            Server server = new Server.Builder().setServerId("server_" + i).setMetadata(metadata).build();            servers.add(server);        }        return servers;    }}